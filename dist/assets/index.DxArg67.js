(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))s(a);new MutationObserver(a=>{for(const n of a)if(n.type==="childList")for(const r of n.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function e(a){const n={};return a.integrity&&(n.integrity=a.integrity),a.referrerPolicy&&(n.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?n.credentials="include":a.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(a){if(a.ep)return;a.ep=!0;const n=e(a);fetch(a.href,n)}})();const i={CANVAS_WIDTH:1200,CANVAS_HEIGHT:1200,LANE_WIDTH:3,N_LANES_MAIN:2,N_LANES_SEC:2,CAR_LENGTH:5,CAR_WIDTH:2.5,TRUCK_LENGTH:10,TRUCK_WIDTH:3,RADIUS_RIGHT:7.5,RADIUS_LEFT:11.25,LEN_RIGHT:11.78,LEN_LEFT:17.67,CENTER_X_REL:.5,CENTER_Y_REL:-.5,OFFSET_MAIN:3,OFFSET_SEC:3,OFFSET_20_TARGET:4.5,N_SEGM:100,DU_LINE:15,BOUNDARY_STRIP_WIDTH:.9,REF_SIZE_PHYS:200,ASPECT_RATIO:1,INTERSECTION_SIZE:120,ROAD_WIDTH:60,CAR_COLORS:["#FF0000","#00FF00","#0000FF","#FFFF00","#FFA500","#FFFFFF","#000000","#888888"],DIRECTIONS:{NORTH:"north",SOUTH:"south",EAST:"east",WEST:"west"},TURN_TYPES:{STRAIGHT:"straight",LEFT:"left",RIGHT:"right"},MODES:{FIXED:"fixed",ADAPTIVE:"adaptive"},LIGHT_SIZE:12,LIGHT_STATES:{RED:"red",YELLOW:"yellow",GREEN:"green"},DEFAULT_SETTINGS:{GREEN_DURATION:1e5,YELLOW_DURATION:5e3,RED_DURATION:1e5,CAR_SPAWN_RATE:4,CAR_SPEED:25,TURN_RATE:.4,DETECTOR_DISTANCE:500,MIN_GREEN_TIME:5e3},TURN_DELAYS:{LEFT:2e3,RIGHT:1500,STRAIGHT:0},HEADINGS:{NORTH:270,SOUTH:90,EAST:0,WEST:180},ROAD_IDS:{EAST_BOUND:0,WEST_BOUND:1,NORTH_BOUND:2,SOUTH_BOUND:4,NORTH_EXIT:3,SOUTH_EXIT:5},ADAPTIVE_SETTINGS:{DETECTOR_DISTANCE_RANGE:[100,500]}};class R{constructor(t,e){this.centerX=t,this.centerY=e,this.laneWidth=i.LANE_WIDTH,this.nLanesMain=i.N_LANES_MAIN,this.nLanesSec=i.N_LANES_SEC,this.radiusRight=i.RADIUS_RIGHT,this.radiusLeft=i.RADIUS_LEFT,this.lenRight=i.LEN_RIGHT,this.lenLeft=i.LEN_LEFT,this.scale=i.CANVAS_WIDTH/i.REF_SIZE_PHYS,this.roads=[],this.nSegm=i.N_SEGM,this.initializeRoads(),this.calculatePositions()}initializeRoads(){this.roads=[this.createRoad(0,"east-bound"),this.createRoad(1,"west-bound"),this.createRoad(2,"north-bound"),this.createRoad(3,"north-exit"),this.createRoad(4,"south-bound"),this.createRoad(5,"south-exit")],this.setupTrajectories(),this.setupAlternativeTrajectories()}createRoad(t,e){return{id:t,type:e,roadLen:200,nLanes:e.includes("main")?this.nLanesMain:this.nLanesSec,traj:[null,null],trajAlt:[],draw_x:new Array(this.nSegm),draw_y:new Array(this.nSegm),draw_phi:new Array(this.nSegm),draw_cosphi:new Array(this.nSegm),draw_sinphi:new Array(this.nSegm)}}setupTrajectories(){const t=this.centerX/this.scale,e=this.centerY/this.scale,s=i.OFFSET_MAIN,a=i.OFFSET_SEC,n=i.OFFSET_20_TARGET;this.roads[0].traj[0]=r=>t+r-.5*this.roads[0].roadLen,this.roads[0].traj[1]=r=>e-s,this.roads[1].traj[0]=r=>t-r+.5*this.roads[1].roadLen,this.roads[1].traj[1]=r=>e+s,this.roads[2].traj[0]=r=>t+a,this.roads[2].traj[1]=r=>e-n-this.radiusRight-this.roads[2].roadLen+r,this.roads[3].traj[0]=r=>t-a,this.roads[3].traj[1]=r=>e+n+this.radiusRight+r,this.roads[4].traj[0]=r=>t-a,this.roads[4].traj[1]=r=>e+n+this.radiusRight+this.roads[4].roadLen-r,this.roads[5].traj[0]=r=>t+a,this.roads[5].traj[1]=r=>e-n-this.radiusRight-r,this.roads.forEach(r=>this.precomputeDrawingArrays(r))}setupAlternativeTrajectories(){const t=this.centerX/this.scale,e=this.centerY/this.scale,s=104.16;this.setupRightTurnTrajectory(0,2,t,e,s),this.setupRightTurnTrajectory(1,4,t,e,s),this.setupRightTurnTrajectory(2,0,t,e,s),this.setupRightTurnTrajectory(4,1,t,e,s),this.setupLeftTurnTrajectory(0,3,t,e,s),this.setupLeftTurnTrajectory(1,5,t,e,s),this.setupLeftTurnTrajectory(2,1,t,e,s),this.setupLeftTurnTrajectory(4,0,t,e,s)}setupRightTurnTrajectory(t,e,s,a,n){const r=this.roads[t],o=t<2?i.OFFSET_MAIN:i.OFFSET_SEC,c=i.OFFSET_20_TARGET,d=(T,S=0)=>{const u=T-n,E=s+o+this.radiusRight;return u<0?E-(this.radiusRight+S):E-(this.radiusRight+S)*Math.cos(u/this.radiusRight)},l=(T,S=0)=>{const u=T-n,E=a-c-this.radiusRight;return u<0?E+u:E+(this.radiusRight+S)*Math.sin(u/this.radiusRight)};r.trajAlt.push({x:d,y:l,roadID:e,umin:n,umax:n+this.lenRight,laneMin:r.nLanes-1,laneMax:r.nLanes-1})}setupLeftTurnTrajectory(t,e,s,a,n){const r=this.roads[t],o=t<2?i.OFFSET_MAIN:i.OFFSET_SEC,c=this.lenLeft-i.LEN_LEFT,d=(T,S=0)=>{const u=s+o-this.radiusLeft,E=T-n;return E<c?u+(this.radiusLeft+S):u+(this.radiusLeft+S)*Math.cos((E-c)/this.radiusLeft)},l=(T,S=0)=>{const u=a-i.OFFSET_20_TARGET-this.radiusLeft,E=T-n;return E<c?u+E:u+(this.radiusLeft+S)*Math.sin((E-c)/this.radiusLeft)};r.trajAlt.push({x:d,y:l,roadID:e,umin:n,umax:n+this.lenLeft,laneMin:0,laneMax:0})}precomputeDrawingArrays(t){const e=t.roadLen/this.nSegm;for(let s=0;s<this.nSegm;s++){const a=(s+.5)*e;t.draw_x[s]=t.traj[0](a),t.draw_y[s]=t.traj[1](a),t.draw_phi[s]=this.get_phi(a,t.traj,t.roadLen),t.draw_cosphi[s]=Math.cos(t.draw_phi[s]),t.draw_sinphi[s]=Math.sin(t.draw_phi[s])}}get_phi(t,e,s){const n=Math.max(.1,Math.min(s-.1,t)),r=e[0](n+.1)-e[0](n-.1),o=e[1](n+.1)-e[1](n-.1);let c=Math.abs(r)<1e-7?.5*Math.PI:Math.atan(o/r);return(r<0||Math.abs(r)<1e-7&&o<0)&&(c+=Math.PI),c}calculatePositions(){const t=i.INTERSECTION_SIZE/2,e=i.ROAD_WIDTH/2,s=i.LANE_WIDTH/2,a=t+5;this.stopLines={[i.DIRECTIONS.NORTH]:{x1:this.centerX-e,y1:this.centerY-a,x2:this.centerX+e,y2:this.centerY-a},[i.DIRECTIONS.EAST]:{x1:this.centerX+a,y1:this.centerY-e,x2:this.centerX+a,y2:this.centerY+e},[i.DIRECTIONS.SOUTH]:{x1:this.centerX-e,y1:this.centerY+a,x2:this.centerX+e,y2:this.centerY+a},[i.DIRECTIONS.WEST]:{x1:this.centerX-a,y1:this.centerY-e,x2:this.centerX-a,y2:this.centerY+e}},this.lightPositions={[i.DIRECTIONS.NORTH]:{x:this.centerX-25,y:this.centerY-t-40},[i.DIRECTIONS.EAST]:{x:this.centerX+t+15,y:this.centerY-25},[i.DIRECTIONS.SOUTH]:{x:this.centerX+25,y:this.centerY+t+15},[i.DIRECTIONS.WEST]:{x:this.centerX-t-40,y:this.centerY+25}},this.spawnPoints={[i.DIRECTIONS.NORTH]:{x:this.centerX-s,y:0},[i.DIRECTIONS.EAST]:{x:i.CANVAS_WIDTH,y:this.centerY-s},[i.DIRECTIONS.SOUTH]:{x:this.centerX+s,y:i.CANVAS_HEIGHT},[i.DIRECTIONS.WEST]:{x:0,y:this.centerY+s}},this.updateSpawnPointsForLanes(),this.exitPoints={[i.DIRECTIONS.NORTH]:{x:this.centerX+s,y:0},[i.DIRECTIONS.EAST]:{x:i.CANVAS_WIDTH,y:this.centerY+s},[i.DIRECTIONS.SOUTH]:{x:this.centerX-s,y:i.CANVAS_HEIGHT},[i.DIRECTIONS.WEST]:{x:0,y:this.centerY-s}}}updateSpawnPointsForLanes(){const t=i.LANE_WIDTH/2;this.spawnPointsByLane={[i.DIRECTIONS.NORTH]:[{x:this.centerX-t,y:0},{x:this.centerX+t,y:i.CANVAS_HEIGHT}],[i.DIRECTIONS.EAST]:[{x:i.CANVAS_WIDTH,y:this.centerY-t},{x:0,y:this.centerY+t}],[i.DIRECTIONS.SOUTH]:[{x:this.centerX+t,y:i.CANVAS_HEIGHT},{x:this.centerX-t,y:0}],[i.DIRECTIONS.WEST]:[{x:0,y:this.centerY+t},{x:i.CANVAS_WIDTH,y:this.centerY-t}]}}getSpawnPointForLane(t,e){return this.spawnPointsByLane[t]?this.spawnPointsByLane[t][e]:this.spawnPoints[t]}render(t){this.drawRoads(t),this.drawIntersection(t),this.drawLaneMarkings(t),this.drawStopLines(t)}drawRoads(t){this.roads.forEach(e=>{this.drawRoadSegments(t,e)})}drawRoadSegments(t,e){const s=e.roadLen/this.nSegm,a=this.scale*s,n=this.scale*(e.nLanes*this.laneWidth+i.BOUNDARY_STRIP_WIDTH);t.fillStyle="#444444";for(let r=0;r<this.nSegm;r++){const o=this.scale*e.draw_x[r],c=-this.scale*e.draw_y[r],d=e.draw_cosphi[r],l=e.draw_sinphi[r];t.save(),t.setTransform(d,-l,+l,d,o,c),t.fillRect(-.5*a,-.5*n,a,n),t.restore()}}drawIntersection(t){const e=i.ROAD_WIDTH/2,s=e;t.fillStyle="#666666",t.beginPath(),t.moveTo(this.centerX-e,this.centerY-e-s),t.quadraticCurveTo(this.centerX-e,this.centerY-e,this.centerX-e-s,this.centerY-e),t.lineTo(this.centerX-e-s,this.centerY+e),t.quadraticCurveTo(this.centerX-e,this.centerY+e,this.centerX-e,this.centerY+e+s),t.lineTo(this.centerX+e,this.centerY+e+s),t.quadraticCurveTo(this.centerX+e,this.centerY+e,this.centerX+e+s,this.centerY+e),t.lineTo(this.centerX+e+s,this.centerY-e),t.quadraticCurveTo(this.centerX+e,this.centerY-e,this.centerX+e,this.centerY-e-s),t.closePath(),t.fill()}drawLaneMarkings(t){t.strokeStyle="#ffffff",t.lineWidth=2,t.setLineDash([10,10]);const e=i.ROAD_WIDTH/2;t.beginPath(),t.moveTo(this.centerX,0),t.lineTo(this.centerX,this.centerY-e),t.moveTo(this.centerX,this.centerY+e),t.lineTo(this.centerX,i.CANVAS_HEIGHT),t.stroke(),t.beginPath(),t.moveTo(0,this.centerY),t.lineTo(this.centerX-e,this.centerY),t.moveTo(this.centerX+e,this.centerY),t.lineTo(i.CANVAS_WIDTH,this.centerY),t.stroke(),t.setLineDash([])}drawStopLines(t){t.strokeStyle="#ffffff",t.lineWidth=4,Object.values(this.stopLines).forEach(e=>{t.beginPath(),t.moveTo(e.x1,e.y1),t.lineTo(e.x2,e.y2),t.stroke()})}getStopLinePosition(t){return this.stopLines[t]}getLightPosition(t){if(!t||typeof t!="string"){console.warn("Invalid direction for getLightPosition:",t);return}return this.lightPositions[t]}isInIntersection(t,e){const s=i.ROAD_WIDTH/2;return t>=this.centerX-s&&t<=this.centerX+s&&e>=this.centerY-s&&e<=this.centerY+s}getExitPoint(t){switch(t){case"north":return{x:this.centerX,y:this.centerY-300};case"south":return{x:this.centerX,y:this.centerY+300};case"east":return{x:this.centerX+300,y:this.centerY};case"west":return{x:this.centerX-300,y:this.centerY};default:return}}getPathEntryPoint(t){const e=i.ROAD_WIDTH/2,s=i.LANE_WIDTH/2;switch(t){case i.DIRECTIONS.NORTH:return{x:this.centerX-s,y:this.centerY-e};case i.DIRECTIONS.EAST:return{x:this.centerX+e,y:this.centerY-s};case i.DIRECTIONS.SOUTH:return{x:this.centerX+s,y:this.centerY+e};case i.DIRECTIONS.WEST:return{x:this.centerX-e,y:this.centerY+s}}}setCarManager(t){this.carManager=t}getAllCars(){return this.carManager?this.carManager.getCars():[]}getVehiclePosition(t,e,s){const a=this.roads[t];if(!a)return null;const n=e-.5*i.CAR_LENGTH,r=this.laneWidth*(s-.5*(a.nLanes-1)),o=a.traj[0](n)+r*Math.cos(this.get_phi(n,a.traj,a.roadLen)+Math.PI/2),c=a.traj[1](n)+r*Math.sin(this.get_phi(n,a.traj,a.roadLen)+Math.PI/2);return{x:o*this.scale,y:-c*this.scale}}getVehicleOrientation(t,e,s,a){const n=this.roads[t];if(!n)return 0;const r=e-.5*i.CAR_LENGTH,o=this.get_phi(r,n.traj,n.roadLen),c=-Math.atan(s*this.laneWidth/a);return o+c}}class g{initialize(t,e){this.mode=t,this.settings={...e},t===i.MODES.FIXED?this.initializeFixedMode():t===i.MODES.ADAPTIVE&&this.initializeAdaptiveMode()}constructor(){this.lights={},this.mode=i.MODES.FIXED,this.settings={...i.DEFAULT_SETTINGS},this.fixedState={currentPhase:0,phaseTimer:0,isActive:!1},this.adaptiveState={currentPair:null,currentPhase:"red",phaseTimer:0,isActive:!1,priorityScores:{WE:0,NS:0},lastSwitchTime:0,firstCarTriggered:!1},this.initializeLights()}initializeLights(){Object.values(i.DIRECTIONS).forEach(t=>{this.lights[t]={state:i.LIGHT_STATES.RED,timer:0}})}initializeFixedMode(){console.log("Initializing Fixed Mode"),this.fixedState={currentPhase:0,phaseTimer:0,isActive:!0},this.setFixedLightState()}initializeAdaptiveMode(){console.log("Initializing Adaptive Mode"),this.adaptiveState={currentPair:null,currentPhase:"red",phaseTimer:0,isActive:!0,priorityScores:{WE:0,NS:0},lastSwitchTime:0,firstCarTriggered:!1},this.setAllLightsRed()}update(t,e,s){this.mode=e,this.settings={...s},e===i.MODES.FIXED?(this.fixedState.isActive||this.initializeFixedMode(),this.updateFixedMode(t)):e===i.MODES.ADAPTIVE&&(this.adaptiveState.isActive||this.initializeAdaptiveMode(),this.updateAdaptiveMode(t))}updateFixedMode(t){switch(this.fixedState.phaseTimer+=t,this.fixedState.currentPhase){case 0:this.fixedState.phaseTimer>=this.settings.GREEN_DURATION&&this.advanceFixedPhase();break;case 1:this.fixedState.phaseTimer>=this.settings.YELLOW_DURATION&&this.advanceFixedPhase();break;case 2:this.fixedState.phaseTimer>=3e3&&this.advanceFixedPhase();break;case 3:this.fixedState.phaseTimer>=this.settings.GREEN_DURATION&&this.advanceFixedPhase();break;case 4:this.fixedState.phaseTimer>=this.settings.YELLOW_DURATION&&this.advanceFixedPhase();break;case 5:this.fixedState.phaseTimer>=3e3&&this.advanceFixedPhase();break}}advanceFixedPhase(){this.fixedState.currentPhase=(this.fixedState.currentPhase+1)%6,this.fixedState.phaseTimer=0,this.setFixedLightState(),console.log(`Fixed Mode: Advanced to phase ${this.fixedState.currentPhase}`)}setFixedLightState(){switch(this.setAllLightsRed(),this.fixedState.currentPhase){case 0:this.lights[i.DIRECTIONS.NORTH].state=i.LIGHT_STATES.GREEN,this.lights[i.DIRECTIONS.SOUTH].state=i.LIGHT_STATES.GREEN;break;case 1:this.lights[i.DIRECTIONS.NORTH].state=i.LIGHT_STATES.YELLOW,this.lights[i.DIRECTIONS.SOUTH].state=i.LIGHT_STATES.YELLOW;break;case 2:break;case 3:this.lights[i.DIRECTIONS.WEST].state=i.LIGHT_STATES.GREEN,this.lights[i.DIRECTIONS.EAST].state=i.LIGHT_STATES.GREEN;break;case 4:this.lights[i.DIRECTIONS.WEST].state=i.LIGHT_STATES.YELLOW,this.lights[i.DIRECTIONS.EAST].state=i.LIGHT_STATES.YELLOW;break}}updateAdaptiveMode(t){if(this.adaptiveState.phaseTimer+=t,this.adaptiveState.currentPair===null){const e=this.getHighestPriorityPair();e&&this.adaptiveState.priorityScores[e]>0&&(console.log(`Adaptive Mode: First car detected, switching to ${e}`),this.switchToAdaptivePair(e));return}switch(this.adaptiveState.currentPhase){case"green":this.shouldSwitchInAdaptive()&&(console.log("Adaptive Mode: Switching due to higher priority"),this.startAdaptiveYellow());break;case"yellow":this.adaptiveState.phaseTimer>=this.settings.YELLOW_DURATION&&this.startAdaptiveRed();break;case"red":if(this.adaptiveState.phaseTimer>=2e3){const s=this.getHighestPriorityPair();s&&s!==this.adaptiveState.currentPair?this.switchToAdaptivePair(s):s===this.adaptiveState.currentPair&&this.startAdaptiveGreen()}break}}switchToAdaptivePair(t){this.adaptiveState.currentPair=t,this.startAdaptiveGreen()}startAdaptiveGreen(){this.adaptiveState.currentPhase="green",this.adaptiveState.phaseTimer=0,this.setAdaptiveLightState(),console.log(`Adaptive Mode: ${this.adaptiveState.currentPair} lights turned GREEN`)}startAdaptiveYellow(){this.adaptiveState.currentPhase="yellow",this.adaptiveState.phaseTimer=0,this.setAdaptiveLightState(),console.log(`Adaptive Mode: ${this.adaptiveState.currentPair} lights turned YELLOW`)}startAdaptiveRed(){this.adaptiveState.currentPhase="red",this.adaptiveState.phaseTimer=0,this.adaptiveState.lastSwitchTime=Date.now(),this.setAllLightsRed(),console.log(`Adaptive Mode: ${this.adaptiveState.currentPair} lights turned RED`)}setAdaptiveLightState(){if(this.setAllLightsRed(),this.adaptiveState.currentPair==="WE"){const t=this.adaptiveState.currentPhase==="green"?i.LIGHT_STATES.GREEN:this.adaptiveState.currentPhase==="yellow"?i.LIGHT_STATES.YELLOW:i.LIGHT_STATES.RED;this.lights[i.DIRECTIONS.WEST].state=t,this.lights[i.DIRECTIONS.EAST].state=t}else if(this.adaptiveState.currentPair==="NS"){const t=this.adaptiveState.currentPhase==="green"?i.LIGHT_STATES.GREEN:this.adaptiveState.currentPhase==="yellow"?i.LIGHT_STATES.YELLOW:i.LIGHT_STATES.RED;this.lights[i.DIRECTIONS.NORTH].state=t,this.lights[i.DIRECTIONS.SOUTH].state=t}}shouldSwitchInAdaptive(){const t=this.adaptiveState.currentPair,e=t==="WE"?"NS":"WE",s=this.adaptiveState.priorityScores[t]||0,a=this.adaptiveState.priorityScores[e]||0;return a>s*1.5&&a>10}getHighestPriorityPair(){const t=this.adaptiveState.priorityScores.WE||0,e=this.adaptiveState.priorityScores.NS||0;return t>e&&t>0?"WE":e>t&&e>0?"NS":null}updateAdaptiveLogic(t,e){if(this.mode!==i.MODES.ADAPTIVE||!this.adaptiveState.isActive)return;const s=this.adaptiveState.currentPhase;this.lastPhase&&this.lastPhase!==s&&console.log(`Adaptive Mode: Phase changed from ${this.lastPhase} to ${s}, car counts will reset`),this.lastPhase=s;const a=this.calculatePairScore("WE",t),n=this.calculatePairScore("NS",t);this.adaptiveState.priorityScores={WE:a,NS:n}}calculatePairScore(t,e){let s=0;if(t==="WE"){const a=e[i.DIRECTIONS.WEST]||{carsWaiting:0,waitTime:0,totalCarsDetected:0},n=e[i.DIRECTIONS.EAST]||{carsWaiting:0,waitTime:0,totalCarsDetected:0};s=a.carsWaiting*(a.waitTime/1e3)+n.carsWaiting*(n.waitTime/1e3)+a.totalCarsDetected+n.totalCarsDetected}else if(t==="NS"){const a=e[i.DIRECTIONS.NORTH]||{carsWaiting:0,waitTime:0,totalCarsDetected:0},n=e[i.DIRECTIONS.SOUTH]||{carsWaiting:0,waitTime:0,totalCarsDetected:0};s=a.carsWaiting*(a.waitTime/1e3)+n.carsWaiting*(n.waitTime/1e3)+a.totalCarsDetected+n.totalCarsDetected}return s}setAllLightsRed(){Object.values(i.DIRECTIONS).forEach(t=>{this.lights[t].state=i.LIGHT_STATES.RED})}render(t,e){["north","south","east","west"].forEach(a=>{const n=this.lights[i.DIRECTIONS[a.toUpperCase()]].state;this.renderTrafficLight(t,a,n,e)})}renderTrafficLight(t,e,s,a){const n=a.getLightPosition(e);if(!n)return;const r=i.LIGHT_SIZE,o=r+2;t.fillStyle="#333",t.fillRect(n.x-r-1,n.y-o*1.5-1,(r+1)*2,o*3+2),["red","yellow","green"].forEach((d,l)=>{const T=n.y-o+l*o;t.fillStyle="#222",t.beginPath(),t.arc(n.x,T,r,0,Math.PI*2),t.fill(),s===d&&(t.fillStyle=d,t.beginPath(),t.arc(n.x,T,r-2,0,Math.PI*2),t.fill())})}getLightStates(){const t={};return Object.entries(this.lights).forEach(([e,s])=>{t[e]=s.state}),t}setMode(t){this.mode=t,t===i.MODES.FIXED&&!this.fixedState.isActive?this.initializeFixedMode():t===i.MODES.ADAPTIVE&&!this.adaptiveState.isActive&&this.initializeAdaptiveMode()}updateSettings(t){this.settings={...t}}reset(){this.mode===i.MODES.FIXED?(this.fixedState.isActive=!1,this.initializeFixedMode()):this.mode===i.MODES.ADAPTIVE&&(this.adaptiveState.isActive=!1,this.initializeAdaptiveMode()),console.log(`${this.mode} mode reset`)}getDebugInfo(){return this.mode===i.MODES.FIXED?{mode:"Fixed",phase:this.fixedState.currentPhase,timer:(this.fixedState.phaseTimer/1e3).toFixed(1)+"s",active:this.fixedState.isActive}:{mode:"Adaptive",pair:this.adaptiveState.currentPair,phase:this.adaptiveState.currentPhase,timer:(this.adaptiveState.phaseTimer/1e3).toFixed(1)+"s",scores:this.adaptiveState.priorityScores,active:this.adaptiveState.isActive}}}const C={getDistance(h,t,e,s){const a=e-h,n=s-t;return Math.sqrt(a*a+n*n)},getAngle(h,t,e,s){return Math.atan2(s-t,e-h)},getAngleDifference(h,t){let e=t-h;for(;e>Math.PI;)e-=2*Math.PI;for(;e<-Math.PI;)e+=2*Math.PI;return e},normalizeAngle(h){for(;h>Math.PI;)h-=2*Math.PI;for(;h<-Math.PI;)h+=2*Math.PI;return h},lerp(h,t,e){return h+(t-h)*e},clamp(h,t,e){return Math.min(Math.max(h,t),e)},randomBetween(h,t){return Math.random()*(t-h)+h},randomInt(h,t){return Math.floor(Math.random()*(t-h+1))+h},randomFromArray(h){return h[Math.floor(Math.random()*h.length)]},formatTime(h){return(h/1e3).toFixed(1)},hexToRgba(h,t=1){const e=parseInt(h.slice(1,3),16),s=parseInt(h.slice(3,5),16),a=parseInt(h.slice(5,7),16);return`rgba(${e}, ${s}, ${a}, ${t})`},isPointInRect(h,t,e,s,a,n){return h>=e&&h<=e+a&&t>=s&&t<=s+n},smoothStep(h,t,e){const s=this.clamp((e-h)/(t-h),0,1);return s*s*(3-2*s)},getBezierPoint(h,t,e,s,a){const n=3*(e.x-t.x),r=3*(s.x-e.x)-n,o=a.x-t.x-n-r,c=3*(e.y-t.y),d=3*(s.y-e.y)-c,l=a.y-t.y-c-d,T=h*h,S=T*h;return{x:o*S+r*T+n*h+t.x,y:l*S+d*T+c*h+t.y}}};class f{constructor({id:t,direction:e,intersection:s,route:a=null,lane:n=0,roadId:r=null}){this.id=t,this.fromDirection=e,this.intersection=s,this.route=a||[e,"intersection",this.calculateToDirection()],this.lane=n,this.lateralPosition=0,this.turnType=this.calculateTurnType(),this.toDirection=this.route[2],this.roadId=r||this.getRoadIdFromDirection(e),this.u=0,this.v=n,this.dvdt=0,this.len=i.CAR_LENGTH;const o=s.getSpawnPointForLane(e,n);this.x=o.x,this.y=o.y,this.angle=this.getInitialAngle(),this.speed=0,this.maxSpeed=i.DEFAULT_SETTINGS.CAR_SPEED*i.LANE_WIDTH,this.width=i.CAR_WIDTH/i.LANE_WIDTH,this.height=i.CAR_HEIGHT/i.LANE_WIDTH,this.color=i.CAR_COLORS[Math.floor(Math.random()*i.CAR_COLORS.length)],this.state="approaching",this.waitStartTime=null,this.totalWaitTime=0,this.isInIntersection=!1,this.pathProgress=0,this.turnStartTime=null,this.isHidden=!1,this.initializePhysicalPosition(),this.calculateTargetPosition()}getRoadIdFromDirection(t){switch(t){case i.DIRECTIONS.EAST:return i.ROAD_IDS.EAST_BOUND;case i.DIRECTIONS.WEST:return i.ROAD_IDS.WEST_BOUND;case i.DIRECTIONS.NORTH:return i.ROAD_IDS.NORTH_BOUND;case i.DIRECTIONS.SOUTH:return i.ROAD_IDS.SOUTH_BOUND;default:return 0}}initializePhysicalPosition(){this.u=10,this.v=this.lane,this.updatePixelPosition()}updatePixelPosition(){const t=this.intersection.getVehiclePosition(this.roadId,this.u,this.v);t&&(this.x=t.x,this.y=t.y,this.angle=this.intersection.getVehicleOrientation(this.roadId,this.u,this.dvdt,this.speed))}calculateTurnType(){const t=Math.random();return t<i.DEFAULT_SETTINGS.TURN_RATE/2?i.TURN_TYPES.LEFT:t<i.DEFAULT_SETTINGS.TURN_RATE?i.TURN_TYPES.RIGHT:i.TURN_TYPES.STRAIGHT}prepareForTurn(){this.turnType==="left"?this.lane=0:this.turnType==="right"&&(this.lane=1)}calculateToDirection(){const t=[i.DIRECTIONS.NORTH,i.DIRECTIONS.EAST,i.DIRECTIONS.SOUTH,i.DIRECTIONS.WEST],e=t.indexOf(this.fromDirection);switch(this.turnType){case i.TURN_TYPES.LEFT:return t[(e+1)%4];case i.TURN_TYPES.RIGHT:return t[(e+3)%4];default:return t[(e+2)%4]}}getInitialAngle(){switch(this.fromDirection){case i.DIRECTIONS.NORTH:return Math.PI/2;case i.DIRECTIONS.EAST:return Math.PI;case i.DIRECTIONS.SOUTH:return-Math.PI/2;case i.DIRECTIONS.WEST:return 0;default:return 0}}calculateTargetPosition(){if(this.intersection&&typeof this.intersection.getExitPoint=="function"&&this.fromDirection){const t=this.intersection.getExitPoint(this.fromDirection);if(!t||typeof t.x!="number"||typeof t.y!="number"){console.warn("Target position is undefined or invalid for car",this.id);return}this.targetX=t.x,this.targetY=t.y}else console.warn("intersection.getExitPoint is not a function or direction is missing")}update(t,e){const s=t/1e3;this.updatePhysicalMovement(s,e),this.updatePixelPosition(),this.isInIntersection=this.intersection.isInIntersection(this.x,this.y)}updatePhysicalMovement(t,e){const s=this.intersection.roads[this.roadId];if(s){switch(this.state){case"approaching":this.updateApproaching(t,e);break;case"waiting":this.updateWaiting(t,e);break;case"crossing":this.updateCrossing(t);break;case"turning":this.updateTurning(t);break;case"exiting":this.updateExiting(t);break}this.speed>0&&!this.isHidden&&(this.u+=this.speed*t),Math.abs(this.dvdt)>.001&&(this.v+=this.dvdt*t,this.v=Math.max(0,Math.min(s.nLanes-1,this.v)))}}updateApproaching(t,e){this.prepareForTurn();const s=this.intersection.getStopLinePosition(this.fromDirection),a=this.getDistanceToStopLine(s),n=this.checkForCarAhead(),r=n&&this.getDistanceToCarAhead(n)<35;if((a<=30||r)&&(e[this.fromDirection]===i.LIGHT_STATES.RED||r)){this.state="waiting",this.speed=0,r||(this.waitStartTime=Date.now());return}this.speed=Math.min(this.maxSpeed,this.speed+10*t),this.isInIntersection&&(this.state="crossing")}updateWaiting(t,e){this.speed=0,this.waitStartTime&&(this.totalWaitTime=Date.now()-this.waitStartTime),(e[this.fromDirection]===i.LIGHT_STATES.GREEN||e[this.fromDirection]===i.LIGHT_STATES.YELLOW)&&(this.state="crossing",this.waitStartTime=null)}updateCrossing(t){this.turnType!==i.TURN_TYPES.STRAIGHT?this.followAlternativeTrajectory(t):this.speed=Math.min(this.maxSpeed*1.2,this.speed+15*t),!this.isInIntersection&&this.pathProgress>0&&(this.state="exiting"),this.pathProgress+=t}followAlternativeTrajectory(t){const s=this.intersection.roads[this.roadId].trajAlt.find(a=>this.u>=a.umin&&this.u<=a.umax&&this.lane>=a.laneMin&&this.lane<=a.laneMax);s&&(this.roadId=s.roadID,this.u=s.umin,this.speed=Math.min(this.maxSpeed*.8,this.speed))}updateTurning(t){const e=i.TURN_DELAYS[this.turnType]||0;if(Date.now()-this.turnStartTime>=e){const a=this.getExitPosition(this.fromDirection,this.turnType,this.lane);this.x=a.x,this.y=a.y,this.angle=this.degreesToRadians(a.heading),this.fromDirection=a.direction,this.isHidden=!1,this.speed=this.maxSpeed,this.state="exiting",this.turnStartTime=null}}getExitPosition(t,e,s){const a=this.intersection.centerX,n=this.intersection.centerY,r=i.LANE_WIDTH,o=i.INTERSECTION_SIZE,c=(s-.5)*r,d=o/2+10;let l,T,S,u;switch(t){case i.DIRECTIONS.NORTH:switch(e){case i.TURN_TYPES.STRAIGHT:l=i.DIRECTIONS.SOUTH,T=a+c,S=n+d,u=i.HEADINGS.SOUTH;break;case i.TURN_TYPES.LEFT:l=i.DIRECTIONS.EAST,T=a+d,S=n+c,u=i.HEADINGS.EAST;break;case i.TURN_TYPES.RIGHT:l=i.DIRECTIONS.WEST,T=a-d,S=n-c,u=i.HEADINGS.WEST;break}break;case i.DIRECTIONS.SOUTH:switch(e){case i.TURN_TYPES.STRAIGHT:l=i.DIRECTIONS.NORTH,T=a-c,S=n-d,u=i.HEADINGS.NORTH;break;case i.TURN_TYPES.LEFT:l=i.DIRECTIONS.WEST,T=a-d,S=n-c,u=i.HEADINGS.WEST;break;case i.TURN_TYPES.RIGHT:l=i.DIRECTIONS.EAST,T=a+d,S=n+c,u=i.HEADINGS.EAST;break}break;case i.DIRECTIONS.EAST:switch(e){case i.TURN_TYPES.STRAIGHT:l=i.DIRECTIONS.WEST,T=a-d,S=n+c,u=i.HEADINGS.WEST;break;case i.TURN_TYPES.LEFT:l=i.DIRECTIONS.NORTH,T=a-c,S=n-d,u=i.HEADINGS.NORTH;break;case i.TURN_TYPES.RIGHT:l=i.DIRECTIONS.SOUTH,T=a+c,S=n+d,u=i.HEADINGS.SOUTH;break}break;case i.DIRECTIONS.WEST:switch(e){case i.TURN_TYPES.STRAIGHT:l=i.DIRECTIONS.EAST,T=a+d,S=n-c,u=i.HEADINGS.EAST;break;case i.TURN_TYPES.LEFT:l=i.DIRECTIONS.SOUTH,T=a+c,S=n+d,u=i.HEADINGS.SOUTH;break;case i.TURN_TYPES.RIGHT:l=i.DIRECTIONS.NORTH,T=a-c,S=n-d,u=i.HEADINGS.NORTH;break}break}return{direction:l,x:T,y:S,heading:u}}degreesToRadians(t){return t*Math.PI/180}getTargetExitAngle(){switch(this.toDirection){case i.DIRECTIONS.NORTH:return-Math.PI/2;case i.DIRECTIONS.EAST:return 0;case i.DIRECTIONS.SOUTH:return Math.PI/2;case i.DIRECTIONS.WEST:return Math.PI;default:return this.angle}}updateExiting(t){this.speed=this.maxSpeed;const e=this.intersection.roads[this.roadId];e&&this.u>=e.roadLen&&(this.state="completed")}getDistanceToStopLine(t){return this.intersection.roads[this.roadId]?Math.max(0,100-this.u):0}render(t){if(this.isHidden)return;const e=this.width*i.LANE_WIDTH,s=this.height*i.LANE_WIDTH;t.save(),t.translate(this.x,this.y),t.rotate(this.angle),t.fillStyle=this.color,t.fillRect(-e/2,-s/2,e,s),t.fillStyle="#333333",t.fillRect(-e/2+2,-s/2+2,e-4,3),t.fillRect(-e/2+2,s/2-5,e-4,3),t.restore()}isWaiting(){return this.state==="waiting"}isCompleted(){return this.state==="completed"}getWaitTime(){return this.totalWaitTime}getDirection(){return this.fromDirection}checkForCarAhead(){const t=this.intersection.carManager?this.intersection.carManager.getCars():[];let e=null,s=1/0;for(const a of t){if(a.id===this.id||a.roadId!==this.roadId)continue;const n=a.u>this.u,r=a.u-this.u;n&&r>0&&r<s&&(s=r,e=a)}return e}getDistanceToCarAhead(t){return t?Math.abs(t.u-this.u):1/0}}class I{constructor(t){this.intersection=t,this.cars=[],this.nextCarId=1,this.spawnTimer=0,this.settings={...i.DEFAULT_SETTINGS},this.onCarCompleted=null,this.intersection.carManager=this}initialize(t){this.settings={...t},this.cars=[],this.nextCarId=1,this.spawnTimer=0}update(t,e){this.spawnTimer+=t;const s=1e4/this.settings.CAR_SPAWN_RATE;this.spawnTimer>=s&&(this.spawnCar(),this.spawnTimer=0),this.cars.forEach(n=>{n.maxSpeed=this.settings.CAR_SPEED,n.update(t,e)}),this.cars.filter(n=>n.isCompleted()).forEach(n=>{this.onCarCompleted&&this.onCarCompleted(n)}),this.cars=this.cars.filter(n=>!n.isCompleted())}spawnCar(){const t=[i.DIRECTIONS.NORTH,i.DIRECTIONS.EAST,i.DIRECTIONS.SOUTH,i.DIRECTIONS.WEST],e=t[Math.floor(Math.random()*t.length)],s=Math.floor(Math.random()*2),a=this.intersection.spawnPoints[e];if(!this.cars.some(r=>{const o=C.getDistance(r.x,r.y,a.x,a.y);return r.fromDirection===e&&o<60})){const r=new f({id:this.nextCarId++,direction:e,intersection:this.intersection,lane:s,roadId:this.getRoadIdFromDirection(e)});this.cars.push(r)}}getRoadIdFromDirection(t){switch(t){case i.DIRECTIONS.EAST:return i.ROAD_IDS.EAST_BOUND;case i.DIRECTIONS.WEST:return i.ROAD_IDS.WEST_BOUND;case i.DIRECTIONS.NORTH:return i.ROAD_IDS.NORTH_BOUND;case i.DIRECTIONS.SOUTH:return i.ROAD_IDS.SOUTH_BOUND;default:return 0}}render(t){this.cars.forEach(e=>e.render(t))}reset(){this.cars=[],this.nextCarId=1,this.spawnTimer=0}updateSettings(t){this.settings={...t}}getCars(){return[...this.cars]}getWaitingCars(t){return this.cars.filter(e=>e.getDirection()===t&&e.isWaiting())}getCurrentCarCount(){return this.cars.length}}class D{constructor(t){this.intersection=t,this.detectorDistance=i.DEFAULT_SETTINGS.DETECTOR_DISTANCE,this.sensorData={},this.carCounts={},this.waitingCars={},this.totalCarsDetected={},this.initializeSensors()}initializeSensors(){Object.values(i.DIRECTIONS).forEach(t=>{this.sensorData[t]={carsWaiting:0,waitTime:0,detectedCars:[],firstCarWaitStart:null,totalCarsDetected:0},this.carCounts[t]=0,this.waitingCars[t]=null,this.totalCarsDetected[t]=0})}initialize(t){this.detectorDistance=t,this.initializeSensors()}update(t,e,s){return Object.values(i.DIRECTIONS).forEach(a=>{this.sensorData[a].carsWaiting=0,this.sensorData[a].waitTime=0,this.sensorData[a].detectedCars=[],this.sensorData[a].firstCarWaitStart=null,this.waitingCars[a]=null}),e&&s&&Object.values(i.DIRECTIONS).forEach(a=>{e[a]!==s[a]&&(this.resetCarCount(a),this.sensorData[a].waitTime=0,this.sensorData[a].carsWaiting=0)}),this.shouldResetCounts&&(this.resetAllCarCounts(),this.shouldResetCounts=!1),t.forEach(a=>{const n=a.getDirection(),r=this.getDetectionZone(n);if(e&&e[n]===i.LIGHT_STATES.RED){const o=this.isCarInDetectionZone(a,r);!a._countedInDetector&&o&&(a._countedInDetector=!0,this.totalCarsDetected[n]++,this.sensorData[n].totalCarsDetected=this.totalCarsDetected[n]),!o&&a._countedInDetector&&(a._countedInDetector=!1),o&&this.sensorData[n].detectedCars.push(a),a.isWaiting()&&o&&(this.sensorData[n].carsWaiting++,(!this.waitingCars[n]||this.isCarCloserToStopLine(a,this.waitingCars[n],n))&&(this.waitingCars[n]=a),this.sensorData[n].firstCarWaitStart||(this.sensorData[n].firstCarWaitStart=Date.now()-a.getWaitTime()))}}),Object.values(i.DIRECTIONS).forEach(a=>{this.waitingCars[a]&&(this.sensorData[a].waitTime=this.waitingCars[a].getWaitTime())}),this.sensorData}isCarCloserToStopLine(t,e,s){const a=this.intersection.getStopLinePosition(s);switch(s){case i.DIRECTIONS.NORTH:return Math.abs(t.y-a.y1)<Math.abs(e.y-a.y1);case i.DIRECTIONS.EAST:return Math.abs(t.x-a.x1)<Math.abs(e.x-a.x1);case i.DIRECTIONS.SOUTH:return Math.abs(t.y-a.y1)<Math.abs(e.y-a.y1);case i.DIRECTIONS.WEST:return Math.abs(t.x-a.x1)<Math.abs(e.x-a.x1);default:return!1}}getDetectionZone(t){const e=this.intersection.getStopLinePosition(t),s=i.ROAD_WIDTH;switch(t){case i.DIRECTIONS.NORTH:return{x1:this.intersection.centerX-s/2,y1:e.y1-this.detectorDistance,x2:this.intersection.centerX+s/2,y2:e.y1};case i.DIRECTIONS.EAST:return{x1:e.x1,y1:this.intersection.centerY-s/2,x2:e.x1+this.detectorDistance,y2:this.intersection.centerY+s/2};case i.DIRECTIONS.SOUTH:return{x1:this.intersection.centerX-s/2,y1:e.y1,x2:this.intersection.centerX+s/2,y2:e.y1+this.detectorDistance};case i.DIRECTIONS.WEST:return{x1:e.x1-this.detectorDistance,y1:this.intersection.centerY-s/2,x2:e.x1,y2:this.intersection.centerY+s/2};default:return{x1:0,y1:0,x2:0,y2:0}}}isCarInDetectionZone(t,e){return t.x>=e.x1&&t.x<=e.x2&&t.y>=e.y1&&t.y<=e.y2}render(t){this.shouldRenderSensors()&&(t.strokeStyle="rgba(255, 165, 0, 0.8)",t.fillStyle="rgba(255, 165, 0, 0.1)",t.lineWidth=2,t.setLineDash([5,5]),Object.values(i.DIRECTIONS).forEach(e=>{const s=this.getDetectionZone(e);t.fillRect(s.x1,s.y1,s.x2-s.x1,s.y2-s.y1),t.strokeRect(s.x1,s.y1,s.x2-s.x1,s.y2-s.y1),this.renderCarCount(t,e,s),this.renderWaitTime(t,e,s)}),t.setLineDash([]))}shouldRenderSensors(){return!0}renderCarCount(t,e,s){const a=this.totalCarsDetected[e]||0;t.fillStyle="rgba(255, 255, 255, 0.95)",t.strokeStyle="#333",t.lineWidth=2,t.font="bold 14px Arial",t.textAlign="center";let n,r;switch(e){case i.DIRECTIONS.NORTH:n=s.x1-40,r=(s.y1+s.y2)/2;break;case i.DIRECTIONS.SOUTH:n=s.x2+40,r=(s.y1+s.y2)/2;break;case i.DIRECTIONS.EAST:n=(s.x1+s.x2)/2,r=s.y1-20;break;case i.DIRECTIONS.WEST:n=(s.x1+s.x2)/2,r=s.y2+30;break}const o=a.toString(),c=t.measureText(o).width,d=Math.max(c+10,30),l=20;t.fillRect(n-d/2,r-l/2,d,l),t.strokeRect(n-d/2,r-l/2,d,l),t.fillStyle="#333",t.fillText(o,n,r+4),t.font="bold 10px Arial",t.fillText(e.charAt(0).toUpperCase(),n,r-15)}renderWaitTime(t,e,s){const a=this.waitingCars[e];if(!a)return;const n=(a.getWaitTime()/1e3).toFixed(1);t.fillStyle="rgba(255, 255, 255, 0.95)",t.strokeStyle="#ff4444",t.lineWidth=2,t.font="bold 12px Arial",t.textAlign="center";let r,o;switch(e){case i.DIRECTIONS.NORTH:r=s.x2+50,o=(s.y1+s.y2)/2;break;case i.DIRECTIONS.SOUTH:r=s.x1-50,o=(s.y1+s.y2)/2;break;case i.DIRECTIONS.EAST:r=(s.x1+s.x2)/2,o=s.y2+50;break;case i.DIRECTIONS.WEST:r=(s.x1+s.x2)/2,o=s.y1-40;break}const c=`${n}s`,d=t.measureText(c).width,l=Math.max(d+8,25),T=18;t.fillRect(r-l/2,o-T/2,l,T),t.strokeRect(r-l/2,o-T/2,l,T),t.fillStyle="#ff4444",t.fillText(c,r,o+3)}updateDetectorDistance(t){this.detectorDistance=t}getSensorData(){return{...this.sensorData}}getCarCounts(){return{...this.carCounts}}getTotalCarsDetected(){return{...this.totalCarsDetected}}resetCarCount(t){this.totalCarsDetected[t]=0}resetAllCarCounts(){Object.values(i.DIRECTIONS).forEach(t=>{this.totalCarsDetected[t]=0}),console.log("Adaptive Mode: Car counts reset for new cycle")}triggerCountReset(){this.shouldResetCounts=!0}reset(){this.initializeSensors()}}class p{constructor(){this.reset()}initialize(){this.reset()}reset(){this.totalCarsPassed=0,this.totalWaitTime=0,this.currentCars=0,this.waitTimes=[]}update(t,e){this.currentCars=t.length}recordCarCompletion(t){this.totalCarsPassed++;const e=t.getWaitTime();e>0&&(this.totalWaitTime+=e,this.waitTimes.push(e))}getStats(){const t=this.waitTimes.length>0?this.waitTimes.reduce((e,s)=>e+s,0)/this.waitTimes.length:0;return{totalCarsPassed:this.totalCarsPassed,averageWaitTime:t/1e3,currentCars:this.currentCars}}}class A{constructor(t,e){this.canvas=t,this.ctx=e,this.intersection=new R(i.CANVAS_WIDTH/2,i.CANVAS_HEIGHT/2),this.mode=i.MODES.FIXED,this.fixedMode={trafficLights:new g,carManager:new I(this.intersection),sensorSystem:new D(this.intersection),statistics:new p,settings:{...i.DEFAULT_SETTINGS}},this.adaptiveMode={trafficLights:new g,carManager:new I(this.intersection),sensorSystem:new D(this.intersection),statistics:new p,settings:{...i.DEFAULT_SETTINGS,YELLOW_DURATION:3e3}}}initialize(){this.intersection.setCarManager(this.fixedMode.carManager),this.fixedMode.trafficLights.initialize(i.MODES.FIXED,this.fixedMode.settings),this.fixedMode.carManager.initialize(this.fixedMode.settings),this.fixedMode.sensorSystem.initialize(this.fixedMode.settings.DETECTOR_DISTANCE),this.fixedMode.statistics.initialize(),this.fixedMode.carManager.onCarCompleted=t=>{this.fixedMode.statistics.recordCarCompletion(t)},this.adaptiveMode.trafficLights.initialize(i.MODES.ADAPTIVE,this.adaptiveMode.settings),this.adaptiveMode.carManager.initialize(this.adaptiveMode.settings),this.adaptiveMode.sensorSystem.initialize(this.adaptiveMode.settings.DETECTOR_DISTANCE),this.adaptiveMode.statistics.initialize(),this.adaptiveMode.carManager.onCarCompleted=t=>{this.adaptiveMode.statistics.recordCarCompletion(t)},console.log("Game engine initialized")}update(t){const e=this.getCurrentModeComponents();this.prevLightStates||(this.prevLightStates=e.trafficLights.getLightStates()),e.trafficLights.update(t,this.mode,e.settings),this.intersection.setCarManager(e.carManager),e.carManager.update(t,e.trafficLights.getLightStates());let s;this.mode===i.MODES.ADAPTIVE?(s=e.sensorSystem.update(e.carManager.getCars(),e.trafficLights.getLightStates(),this.prevLightStates),e.trafficLights.updateAdaptiveLogic(s,t)):s=e.sensorSystem.update(e.carManager.getCars()),this.prevLightStates=e.trafficLights.getLightStates(),e.statistics.update(e.carManager.getCars(),t)}render(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);const t=this.getCurrentModeComponents();this.intersection.render(this.ctx),this.mode===i.MODES.ADAPTIVE&&t.sensorSystem.render(this.ctx),t.carManager.render(this.ctx),t.trafficLights.render(this.ctx,this.intersection)}reset(){this.fixedMode.carManager.reset(),this.fixedMode.trafficLights.reset(),this.fixedMode.sensorSystem.reset(),this.fixedMode.statistics.reset(),this.adaptiveMode.carManager.reset(),this.adaptiveMode.trafficLights.reset(),this.adaptiveMode.sensorSystem.reset(),this.adaptiveMode.statistics.reset(),console.log("Game reset")}getCurrentModeComponents(){return this.mode===i.MODES.FIXED?this.fixedMode:this.adaptiveMode}updateMode(t){const e=this.mode;this.mode=t,t===i.MODES.ADAPTIVE&&e!==i.MODES.ADAPTIVE&&this.adaptiveMode.sensorSystem.resetAllCarCounts(),console.log(`Mode changed from ${e} to: ${t}`)}updateSetting(t,e,s=null){const n=(s||this.mode)===i.MODES.FIXED?this.fixedMode:this.adaptiveMode;switch(n.settings[t]=e,t){case"CAR_SPAWN_RATE":case"CAR_SPEED":case"TURN_RATE":n.carManager.updateSettings(n.settings);break;case"DETECTOR_DISTANCE":n.sensorSystem.updateDetectorDistance(e);break;case"GREEN_DURATION":case"YELLOW_DURATION":case"RED_DURATION":case"MIN_GREEN_TIME":n.trafficLights.updateSettings(n.settings);break}}updateSettings(t){const e=this.getCurrentModeComponents();e.settings={...e.settings,...t},e.trafficLights.updateSettings(e.settings),e.carManager.updateSettings(e.settings)}getStatistics(){return this.getCurrentModeComponents().statistics.getStats()}getLightStates(){return this.getCurrentModeComponents().trafficLights.getLightStates()}getCurrentMode(){return this.mode}getSettings(){return{...this.getCurrentModeComponents().settings}}getFixedModeSettings(){return{...this.fixedMode.settings}}getAdaptiveModeSettings(){return{...this.adaptiveMode.settings}}getSensorSystem(){return this.getCurrentModeComponents().sensorSystem}setLaneMapping(t,e,s){this.laneMapping=t,this.paths=e,this.getPathIndex=s}assignPathToCar(t){const e=this.getPathIndex(t.dir,t.lane,t.move);e!==null&&this.paths[e]&&(t.path=this.paths[e],t.pathIndex=e,t.pathProgress=0)}updateCarPathFollowing(t,e){if(!t.path||t.pathProgress>=t.path.length)return;const s=t.path[t.pathProgress],a=s.x-t.x,n=s.y-t.y,r=Math.sqrt(a*a+n*n),o=t.speed*e;r<o?(t.x=s.x,t.y=s.y,t.pathProgress++):(t.x+=a/r*o,t.y+=n/r*o)}}class N{constructor(t){this.gameEngine=t,this.elements={},this.isPlaying=!0,this.initializeElements()}initializeElements(){this.elements={modeSelect:document.getElementById("mode-select"),playPauseBtn:document.getElementById("playPauseBtn"),resetBtn:document.getElementById("resetBtn"),fixedControls:document.getElementById("fixed-controls"),greenDuration:document.getElementById("greenDuration"),greenValue:document.getElementById("greenDurationValue"),yellowDuration:document.getElementById("yellowDuration"),yellowValue:document.getElementById("yellowDurationValue"),redDuration:document.getElementById("redDuration"),redValue:document.getElementById("redDurationValue"),adaptiveControls:document.getElementById("adaptive-controls"),detectorDistance:document.getElementById("detectorDistance"),minGreenTime:document.getElementById("minGreenTime"),detectorValue:document.getElementById("detectorValue"),minGreenValue:document.getElementById("minGreenValue"),adaptiveYellowDuration:document.getElementById("adaptiveYellowDuration"),adaptiveYellowValue:document.getElementById("adaptiveYellowValue"),carSpawnRate:document.getElementById("carSpawnRate"),carSpeed:document.getElementById("carSpeed"),spawnValue:document.getElementById("spawnValue"),speedValue:document.getElementById("speedValue"),carsPassedStat:document.getElementById("carsPassedStat"),avgWaitStat:document.getElementById("avgWaitStat"),currentCarsStat:document.getElementById("currentCarsStat"),northCountStat:document.getElementById("northCountStat"),southCountStat:document.getElementById("southCountStat"),eastCountStat:document.getElementById("eastCountStat"),westCountStat:document.getElementById("westCountStat"),northLight:document.getElementById("north-light"),eastLight:document.getElementById("east-light"),southLight:document.getElementById("south-light"),westLight:document.getElementById("west-light")}}initialize(){this.setupEventListeners(),this.updateModeDisplay(),this.startStatsUpdate()}setupEventListeners(){this.elements.modeSelect.addEventListener("change",t=>{this.gameEngine.updateMode(t.target.value),this.updateModeDisplay(),this.updateSliderValues()}),this.elements.playPauseBtn.addEventListener("click",()=>{this.isPlaying=window.trafficSimulator.togglePause(),this.elements.playPauseBtn.textContent=this.isPlaying?"⏸️ Pause":"▶️ Play"}),this.elements.resetBtn.addEventListener("click",()=>{this.gameEngine.reset()}),this.setupSlider("greenDuration","greenValue","GREEN_DURATION",t=>t*1e3),this.setupSlider("yellowDuration","yellowValue","YELLOW_DURATION",t=>t*1e3),this.setupSlider("redDuration","redValue","RED_DURATION",t=>t*1e3),this.setupSlider("detectorDistance","detectorValue","DETECTOR_DISTANCE"),this.setupSlider("minGreenTime","minGreenValue","MIN_GREEN_TIME",t=>t*1e3),this.setupSlider("adaptiveYellowDuration","adaptiveYellowValue","YELLOW_DURATION",t=>t*1e3),this.setupSlider("carSpawnRate","spawnValue","CAR_SPAWN_RATE"),this.setupSlider("carSpeed","speedValue","CAR_SPEED")}setupSlider(t,e,s,a=null){const n=this.elements[t],r=this.elements[e];!n||!r||(n.addEventListener("input",o=>{const c=parseFloat(o.target.value);r.textContent=c;const d=a?a(c):c;s==="YELLOW_DURATION"?t==="adaptiveYellowDuration"?this.gameEngine.updateSetting(s,d,i.MODES.ADAPTIVE):this.gameEngine.updateSetting(s,d,i.MODES.FIXED):this.gameEngine.updateSetting(s,d)}),r.textContent=n.value)}updateSliderValues(){const t=this.gameEngine.getCurrentMode(),e=this.gameEngine.getSettings();t===i.MODES.FIXED?(this.elements.greenDuration.value=e.GREEN_DURATION/1e3,this.elements.greenValue.textContent=e.GREEN_DURATION/1e3,this.elements.yellowDuration.value=e.YELLOW_DURATION/1e3,this.elements.yellowValue.textContent=e.YELLOW_DURATION/1e3,this.elements.redDuration.value=e.RED_DURATION/1e3,this.elements.redValue.textContent=e.RED_DURATION/1e3):(this.elements.detectorDistance.value=e.DETECTOR_DISTANCE,this.elements.detectorValue.textContent=e.DETECTOR_DISTANCE,this.elements.minGreenTime.value=e.MIN_GREEN_TIME/1e3,this.elements.minGreenValue.textContent=e.MIN_GREEN_TIME/1e3,this.elements.adaptiveYellowDuration&&(this.elements.adaptiveYellowDuration.value=e.YELLOW_DURATION/1e3,this.elements.adaptiveYellowValue.textContent=e.YELLOW_DURATION/1e3)),this.elements.carSpawnRate.value=e.CAR_SPAWN_RATE,this.elements.spawnValue.textContent=e.CAR_SPAWN_RATE,this.elements.carSpeed.value=e.CAR_SPEED,this.elements.speedValue.textContent=e.CAR_SPEED}updateModeDisplay(){this.gameEngine.getCurrentMode()===i.MODES.FIXED?(this.elements.fixedControls.style.display="block",this.elements.adaptiveControls.style.display="none"):(this.elements.fixedControls.style.display="none",this.elements.adaptiveControls.style.display="block")}startStatsUpdate(){setInterval(()=>{this.updateStatistics(),this.updateLightStatus()},100)}updateStatistics(){const t=this.gameEngine.getStatistics(),e=this.gameEngine.getSensorSystem().getTotalCarsDetected();this.elements.carsPassedStat.textContent=t.totalCarsPassed,this.elements.avgWaitStat.textContent=t.averageWaitTime.toFixed(1)+"s",this.elements.currentCarsStat.textContent=t.currentCars,this.gameEngine.getCurrentMode()==="adaptive"?(this.elements.northCountStat.textContent=e.north||0,this.elements.southCountStat.textContent=e.south||0,this.elements.eastCountStat.textContent=e.east||0,this.elements.westCountStat.textContent=e.west||0):(this.elements.northCountStat.textContent="-",this.elements.southCountStat.textContent="-",this.elements.eastCountStat.textContent="-",this.elements.westCountStat.textContent="-")}updateLightStatus(){const t=this.gameEngine.getLightStates(),e={[i.DIRECTIONS.NORTH]:this.elements.northLight,[i.DIRECTIONS.EAST]:this.elements.eastLight,[i.DIRECTIONS.SOUTH]:this.elements.southLight,[i.DIRECTIONS.WEST]:this.elements.westLight};Object.entries(t).forEach(([s,a])=>{const n=e[s];n&&(n.classList.remove("red","yellow","green"),n.classList.add(a))})}setMode(t){this.elements.modeSelect.value=t}updateSliderValue(t,e){const s=this.elements[t];s&&(s.value=e,s.dispatchEvent(new Event("input")))}}document.getElementById("greenDuration").min=15;document.getElementById("greenDuration").max=100;document.getElementById("redDuration").min=15;document.getElementById("redDuration").max=100;const m=document.getElementById("greenDuration"),O=document.getElementById("greenDurationValue");m.addEventListener("input",()=>{O.textContent=m.value});class y{constructor(){this.canvas=document.getElementById("gameCanvas"),this.ctx=this.canvas.getContext("2d"),this.gameEngine=new A(this.canvas,this.ctx),this.uiController=new N(this.gameEngine),this.trafficLightController=new g,this.isRunning=!0,this.lastTime=0,this.initializeGame(),this.startGameLoop()}initializeGame(){this.canvas.width=i.CANVAS_WIDTH,this.canvas.height=i.CANVAS_HEIGHT,this.gameEngine.initialize(),this.uiController.initialize(),console.log("Traffic Simulator initialized")}startGameLoop(){const t=e=>{const s=e-this.lastTime;if(this.lastTime=e,this.isRunning){const a={GREEN_DURATION:Number(document.getElementById("greenDuration").value)*1e3,YELLOW_DURATION:Number(document.getElementById("yellowDuration").value)*1e3,RED_DURATION:Number(document.getElementById("redDuration").value)*1e3,CAR_SPAWN_RATE:Number(document.getElementById("carSpawnRate").value),CAR_SPEED:Number(document.getElementById("carSpeed").value),MIN_GREEN_TIME:5e3,DETECTOR_DISTANCE:200};this.gameEngine.updateSettings(a),this.gameEngine.update(s)}this.gameEngine.render(),requestAnimationFrame(t)};requestAnimationFrame(t)}pause(){this.isRunning=!1}resume(){this.isRunning=!0}reset(){this.gameEngine.reset()}togglePause(){return this.isRunning=!this.isRunning,this.isRunning}}document.addEventListener("DOMContentLoaded",()=>{window.trafficSimulator=new y});
